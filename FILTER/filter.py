# -*- coding: utf-8 -*-
"""filter.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Mg6pbzophbtsT2fpMUH9GEQEG76FPWDX
"""

import numpy as np
import time

# Kalman Filter For Optimal Position Estimation 
class Kalman_Filter:

  #initilization of variables for kalman filter
  def __init__(self):
    self.previous_point=np.array({0,0,0},dtype=float)
    self.previous_time=0

    self.sensor_noise=0.2 #costant sensor noise
    self.action_uncertanity=0.3  #constant varience

    #state prediction matrix [x,y,z,vx,vy,vz]
    self.x=np.matrix(np.zeros(6).T)  
    # State error matrix
    self.P=np.matrix(np.zeros((6,6)),dtype=float) 

    # Kalman equation constants
    self.A = np.matrix([]) # state transition varies with time
    self.C = np.matrix([])  #
    self.Q = np.matrix([])  # Action Uncertanity varience
    self.R = np.matrix([])  # Sensor noise matrix

    #initilize values in kalman const matrix
    self.activate_kalman_const_matrix()
    self.activate_kalman_const_matrix_time_dependent(delta_t=0.2)

  #method containing kalman const matrixs
  def activate_kalman_const_matrix(self):
    self.C = np.matrix([
                       [1, 0, 0, 1, 0, 0],
                       [0, 1, 0, 0, 1, 0],
                       [0, 0, 1, 0, 0, 1],
                       [0, 0, 0, 0, 0, 0],
                       [0, 0, 0, 0, 0, 0],
                       [0, 0, 0, 0, 0, 0]],dtype=float)
    self.Q = np.matrix([
                       [1, 0, 0, 1, 0, 0],
                       [0, 1, 0, 0, 1, 0],
                       [0, 0, 1, 0, 0, 1],
                       [0, 0, 0, 0, 0, 0],
                       [0, 0, 0, 0, 0, 0],
                       [0, 0, 0, 0, 0, 0]],dtype=float)*self.action_uncertanity
    self.R = np.matrix(np.eye(6,6),dtype=float)*self.sensor_noise
  #method containing kalman matrix varry with delta t
  def activate_kalman_const_matrix_time_dependent(self, delta_t=0.1):
    self.A= np.matrix([
                       [1, 0, 0, delta_t, 0, 0],
                       [0, 1, 0, 0, delta_t, 0],
                       [0, 0, 1, 0, 0, delta_t],
                       [0, 0, 0, 1, 0, 0],
                       [0, 0, 0, 0, 1, 0],
                       [0, 0, 0, 0, 0, 1]],dtype=float)
  def filter(self , measured_point):
    img_capture_time = time.time()
    self.activate_kalman_const_matrix_time_dependent(img_capture_time - self.previous_time)
    x = self.x
    P = self.P
    A = self.A
    C = self.C
    Q = self.Q
    R = self.R

    #measurement vector  
    measured_point , m = self.measured_calc(measured_point)

    # Kalman Equation

    #---Prediction-----
    x = A * x
    P = (A * P * A.T)

    #---Updation or Correction----
    I = np.matrix((np.eye(6,6)))

    Kalman_Gain = P * C.T * ((C * P * C.T) + R).I
    y = m - (C * x)
    self.x = x + (Kalman_Gain * y)
    self.P = (I - (Kalman_Gain * C)) * P

    new_point = np.array(self.x[0:3].T)[0, :]
    self.previous_point = new_point
    self.previous_time = img_capture_time

    return np.append(new_poin , [1]) # cartesian to homogenious

  def measured_calc(self , point):
    point = np.array(point[0:3])
    d_point = point - self.previous_point

    return point , np.matrix(np.concatenate([point , d_point],axis=none)).T